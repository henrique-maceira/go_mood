import express from "express";
import axios from "axios";
import cors from "cors";
import dotenv from "dotenv";

dotenv.config();
const app = express();
app.use(cors());
app.use(express.json());

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

// Mapeamento de categorias do Google para portugu√™s
const categoriaTraducoes = {
  'amusement_park': 'Parque de Divers√µes',
  'aquarium': 'Aqu√°rio',
  'art_gallery': 'Galeria de Arte',
  'bar': 'Bar',
  'beauty_salon': 'Sal√£o de Beleza',
  'bowling_alley': 'Boliche',
  'campground': 'Camping',
  'cultural_center': 'Centro Cultural',
  'establishment': 'Estabelecimento',
  'garden': 'Jardim',
  'gym': 'Academia',
  'karaoke': 'Karaok√™',
  'library': 'Biblioteca',
  'movie_theater': 'Cinema',
  'museum': 'Museu',
  'natural_feature': 'Atra√ß√£o Natural',
  'night_club': 'Vida Noturna',
  'park': 'Parque',
  'place_of_worship': 'Local de Culto',
  'point_of_interest': 'Ponto de Interesse',
  'restaurant': 'Restaurante',
  'spa': 'Spa',
  'sports_complex': 'Complexo Esportivo',
  'stadium': 'Est√°dio',
  'store': 'Loja',
  'theater': 'Teatro',
  'tourist_attraction': 'Ponto Tur√≠stico',
  'zoo': 'Zool√≥gico',
  'arcade': 'Arcade',
  'mountain': 'Montanha'
};

// Fun√ß√£o para traduzir categoria
function traduzirCategoria(categoria) {
  return categoriaTraducoes[categoria] || categoria;
}

// Fun√ß√£o para mapear or√ßamento do usu√°rio para faixas de pre√ßo
function mapearOrcamentoParaPriceLevel(budget) {
  const mapeamento = {
    'gratuito': [0],           // Apenas lugares gratuitos
    'ate-50': [0, 1],          // Gratuito e at√© R$ 50
    '50-100': [0, 1, 2],       // Gratuito, at√© R$ 50 e R$ 50-100
    '100-200': [0, 1, 2, 3],   // Gratuito, at√© R$ 50, R$ 50-100 e R$ 100-200
    '200-500': [0, 1, 2, 3, 4], // Todos os pre√ßos
    'acima-500': [0, 1, 2, 3, 4] // Todos os pre√ßos
  };
  
  return mapeamento[budget] || [0, 1, 2, 3, 4];
}

// Fun√ß√£o para converter price_level para texto em portugu√™s
function priceLevelParaTexto(priceLevel) {
  const mapeamento = {
    0: 'R$0',
    1: 'R$10 ‚Äì R$50',
    2: 'R$50 ‚Äì R$100',
    3: 'R$100 ‚Äì R$200',
    4: 'R$200 ou mais'
  };
  
  return mapeamento[priceLevel] || 'Pre√ßo n√£o informado';
}

// Fun√ß√£o para obter coordenadas a partir de endere√ßo
async function getCoordinatesFromAddress(address) {
  try {
    const response = await axios.get("https://maps.googleapis.com/maps/api/geocode/json", {
      params: {
        address: address,
        key: GOOGLE_API_KEY
      }
    });

    if (response.data.results && response.data.results.length > 0) {
      const location = response.data.results[0].geometry.location;
      return `${location.lat},${location.lng}`;
    }
    throw new Error("Endere√ßo n√£o encontrado");
  } catch (error) {
    throw new Error("Erro ao geocodificar endere√ßo");
  }
}

// Fun√ß√£o para buscar locais por categoria espec√≠fica
async function searchPlacesByCategory(location, category, radius, openNow = false) {
  try {
    console.log(`üîç Buscando categoria: ${category} em ${location} com raio ${radius}m, openNow: ${openNow}`);
    
    const params = {
      location: location,
      radius: radius,
      type: category,
      key: GOOGLE_API_KEY
    };

    // Adicionar filtro de lugares abertos se solicitado
    if (openNow) {
      params.opennow = true;
    }

    const response = await axios.get("https://maps.googleapis.com/maps/api/place/nearbysearch/json", {
      params: params
    });

    console.log(`üìä Resposta da API para ${category}:`, {
      status: response.data.status,
      resultsCount: response.data.results?.length || 0,
      results: response.data.results?.slice(0, 3).map(r => ({ 
        name: r.name, 
        rating: r.rating, 
        user_ratings_total: r.user_ratings_total,
        types: r.types 
      }))
    });

    // Filtrar locais com rating >= 4.5 E pelo menos 100 avalia√ß√µes
    const filteredResults = response.data.results.filter(place => 
      place.rating && 
      place.rating >= 4.5 && 
      place.user_ratings_total && 
      place.user_ratings_total >=100
    );

    console.log(`‚úÖ Locais filtrados para ${category}: ${filteredResults.length} com rating >= 4.8 e 50+ avalia√ß√µes`);
    
    return filteredResults;
  } catch (error) {
    console.error(`‚ùå Erro ao buscar categoria ${category}:`, error.response?.data || error.message);
    return [];
  }
}

app.post("/api/sugestoes", async (req, res) => {
  const { localizacao, tipoRole, tempoDeslocamento, budget, openNow } = req.body;

  console.log('üöÄ Iniciando busca de sugest√µes:', { localizacao, tipoRole, tempoDeslocamento, budget, openNow });

  try {
    let coordinates = localizacao;
    
    // Se n√£o for coordenadas ou estiver vazio, usar localiza√ß√£o padr√£o
    if (!localizacao || localizacao.trim() === '') {
      console.log('üìç Localiza√ß√£o n√£o fornecida, usando S√£o Paulo como padr√£o');
      coordinates = "-23.5505,-46.6333"; // S√£o Paulo
    } else if (!localizacao.includes(',')) {
      console.log('üìç Geocodificando endere√ßo:', localizacao);
      try {
        coordinates = await getCoordinatesFromAddress(localizacao);
        console.log('üìç Coordenadas obtidas:', coordinates);
      } catch (error) {
        console.log('‚ö†Ô∏è Erro ao geocodificar, usando S√£o Paulo como padr√£o');
        coordinates = "-23.5505,-46.6333"; // S√£o Paulo como fallback
      }
    }

    // Categorias espec√≠ficas e relevantes para cada tipo de rol√™
    const categoriasPorTipo = {
      familia: [
        "park",           // Parques
        "museum",         // Museus
        "aquarium",       // Aqu√°rios
        "zoo",           // Zool√≥gicos
        "amusement_park", // Parques de divers√£o
        "restaurant",     // Restaurantes
        "movie_theater",  // Cinemas
        "library"         // Bibliotecas
      ],
      casal: [
        "restaurant",     // Restaurantes
        "movie_theater",  // Cinemas
        "art_gallery",    // Galerias de arte
        "park",          // Parques
        "bar",           // Bares
        "spa",           // Spas
        "tourist_attraction" // Pontos tur√≠sticos
      ],
      fitness: [
        "park",          // Parques
        "gym",           // Academias
        "sports_complex", // Complexos esportivos
        "stadium",       // Est√°dios
      ],
      amigos: [
        "bar",           // Bares
        "night_club",    // Casas noturnas
        "restaurant",    // Restaurantes
        "bowling_alley", // Boliches
        "amusement_park", // Parques de divers√£o
        "movie_theater", // Cinemas
        "karaoke",       // Karaok√™s
        "arcade"         // Arcades
      ],
      cultura: [
        "museum",        // Museus
        "art_gallery",   // Galerias de arte
        "theater",       // Teatros
        "library",       // Bibliotecas
        "tourist_attraction", // Pontos tur√≠sticos
        // "church",        // Igrejas hist√≥ricas
        // "university",    // Universidades
        "cultural_center" // Centros culturais
      ],
      aventura: [
        "park",          // Parques
        "tourist_attraction", // Pontos tur√≠sticos
        "amusement_park", // Parques de divers√£o
        "aquarium",      // Aqu√°rios
        "zoo",          // Zool√≥gicos
        "campground",    // Campings
        "natural_feature", // Atra√ß√µes naturais
        "mountain"       // Montanhas
      ],
      relaxamento: [
        "spa",           // Spas
        "park",          // Parques
        "beauty_salon",  // Sal√µes de beleza
        "restaurant",    // Restaurantes
        "bar",          // Bares
        "library",      // Bibliotecas
        "art_gallery",  // Galerias de arte
        "garden"        // Jardins
      ]
    };

    // Categorias de fallback caso o tipo n√£o seja encontrado
    const categoriasFallback = [
      "restaurant",      // Restaurantes
      "park",           // Parques
      "tourist_attraction", // Pontos tur√≠sticos
      "museum",         // Museus
      "bar"             // Bares
    ];

    const categoriasRelevantes = categoriasPorTipo[tipoRole] || categoriasFallback;
    const radius = tempoDeslocamento * 1000; // converter para metros

    console.log('üéØ Categorias relevantes para', tipoRole, ':', categoriasRelevantes);
    console.log('üìè Raio de busca:', radius, 'metros');

    // Buscar locais por cada categoria relevante
    const allPlaces = [];
    for (const category of categoriasRelevantes) {
      const places = await searchPlacesByCategory(coordinates, category, radius, openNow);
      allPlaces.push(...places);
    }

    console.log(`üìã Total de locais encontrados: ${allPlaces.length}`);

    // Remover duplicatas e ordenar por quantidade de avalia√ß√µes (prioridade) e depois por rating
    const uniquePlaces = allPlaces
      .filter((place, index, self) => 
        index === self.findIndex(p => p.place_id === place.place_id)
      )
      .sort((a, b) => {
        // Primeiro ordena por quantidade de avalia√ß√µes (decrescente)
        const aRatings = a.user_ratings_total || 0;
        const bRatings = b.user_ratings_total || 0;
        if (aRatings !== bRatings) {
          return bRatings - aRatings;
        }
        // Se tiver mesma quantidade de avalia√ß√µes, ordena por rating (decrescente)
        return (b.rating || 0) - (a.rating || 0);
      })
      .slice(0, 50); // Aumentar para 50 locais para ter mais op√ß√µes

    console.log(`üîç Locais √∫nicos ap√≥s filtro: ${uniquePlaces.length}`);

    if (uniquePlaces.length === 0) {
      console.log('‚ö†Ô∏è Nenhum local encontrado! Tentando busca mais ampla...');
      
      // Busca de fallback sem filtro de rating
      const fallbackPlaces = [];
      for (const category of categoriasRelevantes.slice(0, 3)) {
        try {
          const params = {
            location: coordinates,
            radius: radius,
            type: category,
            key: GOOGLE_API_KEY
          };
          
          if (openNow) {
            params.opennow = true;
          }
          
          const response = await axios.get("https://maps.googleapis.com/maps/api/place/nearbysearch/json", {
            params: params
          });
          
          if (response.data.results) {
            fallbackPlaces.push(...response.data.results.slice(0, 5));
          }
        } catch (error) {
          console.error(`Erro na busca de fallback para ${category}:`, error.message);
        }
      }
      
      if (fallbackPlaces.length > 0) {
        console.log(`üîÑ Usando ${fallbackPlaces.length} locais de fallback`);
        uniquePlaces.push(...fallbackPlaces.slice(0, 10));
      }
    }

    // Buscar detalhes completos dos locais
    console.log('üîç Buscando detalhes dos locais...');
    const locaisComComentarios = await Promise.all(
      uniquePlaces.map(async (local) => {
        try {
          const placeDetails = await axios.get("https://maps.googleapis.com/maps/api/place/details/json", {
            params: {
              place_id: local.place_id,
              key: GOOGLE_API_KEY,
              fields: "name,rating,user_ratings_total,reviews,formatted_address,url,photos,price_level,opening_hours,types"
            }
          });

          const dados = placeDetails.data.result;
          
          // Calcular dist√¢ncia real usando Google Distance Matrix API
          let distance = "N/A";
          let travelTime = "N/A";
          
          try {
            const distanceResponse = await axios.get("https://maps.googleapis.com/maps/api/distancematrix/json", {
              params: {
                origins: coordinates,
                destinations: dados.formatted_address,
                mode: "driving",
                key: GOOGLE_API_KEY
              }
            });
            
            if (distanceResponse.data.rows && 
                distanceResponse.data.rows[0] && 
                distanceResponse.data.rows[0].elements && 
                distanceResponse.data.rows[0].elements[0] &&
                distanceResponse.data.rows[0].elements[0].status === "OK") {
              
              const element = distanceResponse.data.rows[0].elements[0];
              distance = element.distance.text;
              travelTime = element.duration.text;
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Erro ao calcular dist√¢ncia para ${dados.name}:`, error.message);
            // Fallback para c√°lculo estimado
            const distanceKm = Math.floor(Math.random() * tempoDeslocamento) + 1;
            distance = `${distanceKm} km`;
            travelTime = `${Math.floor(Math.random() * 30) + 10} min`;
          }
          
          // Converter price_level para texto em portugu√™s
          const estimatedCost = priceLevelParaTexto(dados.price_level);

          return {
            nome: dados.name,
            endereco: dados.formatted_address,
            rating: dados.rating,
            user_ratings_total: dados.user_ratings_total,
            comentarios: dados.reviews?.slice(0, 5).map(r => r.text).join(" | ") || "Sem coment√°rios.",
            link: dados.url,
            imagem: dados.photos?.[0]
              ? `https://maps.googleapis.com/maps/api/place/photo?maxwidth=400&photoreference=${dados.photos[0].photo_reference}&key=${GOOGLE_API_KEY}`
              : null,
            distance: distance,
            travelTime: travelTime,
            estimatedCost,
            types: (dados.types || []).map(traduzirCategoria),
            openingHours: dados.opening_hours?.weekday_text || []
          };
        } catch (error) {
          console.error(`‚ùå Erro ao buscar detalhes do local ${local.place_id}:`, error.message);
          return null;
        }
      })
    );

    // Filtrar locais v√°lidos
    const locaisValidos = locaisComComentarios.filter(local => local !== null);
    console.log(`‚úÖ Locais v√°lidos com detalhes: ${locaisValidos.length}`);

    // Obter faixas de pre√ßo permitidas baseado no or√ßamento
    const priceLevelsPermitidos = mapearOrcamentoParaPriceLevel(budget);
    console.log(`üí∞ Or√ßamento "${budget}" permite price_levels:`, priceLevelsPermitidos);

    // Filtro de categorias seguro - usar apenas categorias relevantes, com 100+ avalia√ß√µes, dentro do or√ßamento e n√£o lojas
    const locaisFiltrados = locaisValidos.filter(l => {
      const ratingOk = l.rating >= 4.5;
      const avaliacoesOk = l.user_ratings_total >= 100;
      const categoriaOk = categoriasRelevantes.some(cat => Array.isArray(l.types) && l.types.includes(cat));
      
      // Filtrar lojas - n√£o permitir estabelecimentos que s√£o apenas lojas
      const isLoja = l.types && (
        l.types.includes('store') || 
        l.types.includes('Loja')
      );
      
      // Extrair price_level do estimatedCost baseado nos novos valores
      let priceLevel;
      if (l.estimatedCost === 'R$0') priceLevel = 0;
      else if (l.estimatedCost === 'R$10 ‚Äì R$50') priceLevel = 1;
      else if (l.estimatedCost === 'R$50 ‚Äì R$100') priceLevel = 2;
      else if (l.estimatedCost === 'R$100 ‚Äì R$200') priceLevel = 3;
      else if (l.estimatedCost === 'R$200 ou mais') priceLevel = 4;
      else priceLevel = 2; // Default para R$50-100 se n√£o conseguir identificar
      
      const orcamentoOk = priceLevelsPermitidos.includes(priceLevel);
      
      if (isLoja) {
        console.log(`‚ùå ${l.nome} removido por ser loja: ${l.types?.join(', ')}`);
      } else if (!orcamentoOk) {
        console.log(`‚ùå ${l.nome} removido por or√ßamento: ${l.estimatedCost} (price_level ${priceLevel}) n√£o est√° em ${priceLevelsPermitidos}`);
      }
      
      return ratingOk && avaliacoesOk && categoriaOk && orcamentoOk && !isLoja;
    });

    console.log(`üéØ Locais filtrados por categoria: ${locaisFiltrados.length}`);

    // Se n√£o h√° locais suficientes, usar todos os v√°lidos
    const locaisParaAnalise = locaisFiltrados.length >= 3 ? locaisFiltrados : locaisValidos;

    console.log(`ü§ñ Enviando ${locaisParaAnalise.length} locais para an√°lise do GPT...`);

    if (locaisParaAnalise.length === 0) {
      console.log('‚ùå Nenhum local para analisar!');
      return res.json({
        resposta: "N√£o encontramos locais pr√≥ximos com as caracter√≠sticas solicitadas. Tente aumentar o tempo de deslocamento ou ajustar suas prefer√™ncias.",
        locais: []
      });
    }

    // Prompt melhorado para o GPT
    const prompt = `Voc√™ √© um especialista em lazer e entretenimento. Analise os seguintes locais para um rol√™ do tipo "${tipoRole}" com or√ßamento "${budget}" e tempo m√°ximo de deslocamento de ${tempoDeslocamento} minutos.

OR√áAMENTO DO USU√ÅRIO: "${budget}"
- gratuito: Apenas lugares gratuitos (R$0)
- ate-50: At√© R$ 50 (R$0 + R$10-R$50)
- 50-100: R$ 50-100 (R$0 + R$10-R$50 + R$50-R$100)
- 100-200: R$ 100-200 (R$0 + R$10-R$50 + R$50-R$100 + R$100-R$200)
- 200-500: R$ 200-500 (todos os pre√ßos)
- acima-500: Acima de R$ 500 (todos os pre√ßos)

FAIXAS DE PRE√áO:
- R$0: Gratuito
- R$10 ‚Äì R$50: Econ√¥mico
- R$50 ‚Äì R$100: Moderado
- R$100 ‚Äì R$200: Elevado
- R$200 ou mais: Premium

Para cada local, classifique como "Ideal", "Aceit√°vel" ou "N√£o Ideal" e explique brevemente o porqu√™, considerando:
- Tipo de rol√™ solicitado
- Or√ßamento dispon√≠vel (IMPORTANTE: respeite o limite de or√ßamento)
- Dist√¢ncia/tempo de deslocamento
- Avalia√ß√£o e coment√°rios dos usu√°rios
- N√£o ser loja.

Locais para an√°lise:

${locaisParaAnalise.map((l, i) =>
  `${i + 1}. ${l.nome} - ${l.endereco}
Avalia√ß√£o: ${l.rating}/5 (${l.user_ratings_total} avalia√ß√µes)
Dist√¢ncia: ${l.distance}
Tempo de viagem: ${l.travelTime}
Custo estimado: ${l.estimatedCost}
Coment√°rios: ${l.comentarios.substring(0, 200)}...`
).join("\n\n")}

Responda APENAS com a classifica√ß√£o de cada local no formato:
1. [Nome do Local] - [Classifica√ß√£o]: [Justificativa]
2. [Nome do Local] - [Classifica√ß√£o]: [Justificativa]
...
N√£o inclua introdu√ß√µes ou conclus√µes, apenas a lista numerada.`;

    console.log('ü§ñ Enviando para GPT...');
    const openaiResp = await axios.post("https://api.openai.com/v1/chat/completions", {
      model: "gpt-4o",
      messages: [
        { 
          role: "system", 
          content: "Voc√™ √© um especialista em lazer e entretenimento que analisa locais baseado em prefer√™ncias espec√≠ficas do usu√°rio. Responda apenas com a classifica√ß√£o dos locais, sem introdu√ß√µes ou conclus√µes." 
        },
        { role: "user", content: prompt }
      ],
      max_tokens: 1000,
      temperature: 0.7
    }, {
      headers: { Authorization: `Bearer ${OPENAI_API_KEY}` }
    });

    const respostaTexto = openaiResp.data.choices[0].message.content;
    console.log('ü§ñ Resposta do GPT:', respostaTexto.substring(0, 200) + '...');

    // Processar a resposta do GPT para extrair apenas os locais "Ideal" e "Aceit√°vel"
    const linhas = respostaTexto.split('\n').filter(linha => linha.trim());
    const locaisAprovados = [];
    
    console.log(`üìù Processando ${linhas.length} linhas da resposta do GPT...`);
    
    for (let i = 0; i < linhas.length && i < locaisParaAnalise.length; i++) {
      const linha = linhas[i];
      const local = locaisParaAnalise[i];
      
      console.log(`üîç Analisando linha ${i + 1}:`, linha.substring(0, 100));
      
      // Verificar se o local foi classificado como "Ideal" ou "Aceit√°vel"
      if (linha.includes('Ideal') || linha.includes('Aceit√°vel')) {
        // Extrair a justificativa do GPT
        const justificativa = linha.split(':').slice(1).join(':').trim();
        
        locaisAprovados.push({
          ...local,
          gptAnalysis: justificativa
        });
        
        console.log(`‚úÖ Local aprovado: ${local.nome}`);
      }
    }

    console.log(`üéâ Locais aprovados pelo GPT: ${locaisAprovados.length}`);

    // Enviar TODOS os locais aprovados pelo GPT, sem limite
    const locaisFinais = locaisAprovados.length > 0 
      ? locaisAprovados 
      : locaisParaAnalise;

    console.log(`üì§ Enviando ${locaisFinais.length} locais finais para o frontend`);

    res.json({
      resposta: `An√°lise conclu√≠da! Encontramos ${locaisFinais.length} locais perfeitos para seu rol√™.`,
      locais: locaisFinais
    });

  } catch (error) {
    console.error("‚ùå Erro completo:", error);
    res.status(500).json({ 
      erro: "Erro ao buscar e classificar sugest√µes.",
      detalhes: error.message 
    });
  }
});

// Endpoint para geolocaliza√ß√£o
app.post("/api/geolocation", async (req, res) => {
  const { latitude, longitude } = req.body;
  
  try {
    const coordinates = `${latitude},${longitude}`;
    
    // Buscar endere√ßo reverso
    const response = await axios.get("https://maps.googleapis.com/maps/api/geocode/json", {
      params: {
        latlng: coordinates,
        key: GOOGLE_API_KEY
      }
    });

    if (response.data.results && response.data.results.length > 0) {
      const address = response.data.results[0].formatted_address;
      res.json({ 
        success: true, 
        coordinates,
        address 
      });
    } else {
      res.json({ 
        success: true, 
        coordinates,
        address: "Localiza√ß√£o atual" 
      });
    }
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: "Erro ao processar localiza√ß√£o" 
    });
  }
});

// Endpoint de teste para verificar APIs
app.get("/api/test", async (req, res) => {
  console.log('üß™ Testando APIs...');
  
  try {
    // Testar Google Places API
    console.log('üîç Testando Google Places API...');
    const googleTest = await axios.get("https://maps.googleapis.com/maps/api/place/nearbysearch/json", {
      params: {
        location: "-23.5505,-46.6333", // S√£o Paulo
        radius: 5000,
        type: "restaurant",
        key: GOOGLE_API_KEY
      }
    });
    
    console.log('‚úÖ Google Places API:', {
      status: googleTest.data.status,
      resultsCount: googleTest.data.results?.length || 0
    });

    // Testar OpenAI API
    console.log('ü§ñ Testando OpenAI API...');
    const openaiTest = await axios.post("https://api.openai.com/v1/chat/completions", {
      model: "gpt-4o",
      messages: [
        { role: "user", content: "Responda apenas com 'OK' se est√° funcionando." }
      ],
      max_tokens: 10
    }, {
      headers: { Authorization: `Bearer ${OPENAI_API_KEY}` }
    });
    
    console.log('‚úÖ OpenAI API:', {
      response: openaiTest.data.choices[0].message.content
    });

    res.json({
      success: true,
      google: {
        status: googleTest.data.status,
        resultsCount: googleTest.data.results?.length || 0
      },
      openai: {
        response: openaiTest.data.choices[0].message.content
      }
    });

  } catch (error) {
    console.error('‚ùå Erro no teste:', error.response?.data || error.message);
    res.status(500).json({
      success: false,
      error: error.response?.data || error.message
    });
  }
});

app.listen(process.env.PORT || 3000, () =>
  console.log("üöÄ Backend rodando em http://localhost:3000")
);
